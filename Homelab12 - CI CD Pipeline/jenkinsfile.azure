// Jenksinfile.azure defines a pipeline for the Azure cloud provider


pipeline {
    // We specify that we are open to having the Jenkins pipeline run on any
    // available agent. 
    // 
    // Per Jenkins's Glossary at https://www.jenkins.io/doc/book/glossary/,
    // an agent "is typically a machine, or container, which connects to a Jenkins controller 
    // and executes tasks when directed by the controller"
    agent any

    // Environment variables in Jenkinsfiles "store configuration settings, credentials,
    // and other dynamic values [that can be] used during build and deployment processes"
    // per https://spacelift.io/blog/jenkins-environment-variables
    environment {
        APP_NAME = "flask-app"
        DOCKER_HUB_USERNAME = "nathanpavl"
        DOCKER_IMAGE_NAME = "${DOCKER_HUB_USERNAME}/${APP_NAME}"
        DOCKER_IMAGE_TAG = "${BUILD_NUMBER}"
        CLOUD_PROVIDER = "Azure"
        PROJECT_DIR = "Homelab12 - CI CD Pipeline"

        // We make the Jenkins AWS pipeline see the paths to the  following folders, in addition to whatever system PATH Jenkins already has
        // This environment block at the pipeline level prepends your tool paths and keeps the original ${env.PATH} â€” safe and scoped only to this pipeline
        PATH = "C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Program Files\\Infracost;C:\\Program Files\\Terraform;C:\\Windows\\System32\\OpenSSH;" + "${env.PATH}"
    }

    stages {

        stage ('Checkout') {
            steps {
                echo "Checking out the code from GitHub"
                // The checkout step will checkout code from source control; 
                // scm is a special variable which instructs the checkout step 
                // to clone the specific revision which triggered this Pipeline run.
                //
                // Per https://www.jenkins.io/doc/book/pipeline/jenkinsfile/
                checkout scm
            }
        }
        
        stage ("Build Docker Image") {
            
            steps {
                // Here we specify the steps for building the Docker image locally
                echo "Building the Docker Image"
                script {
                    dir("${PROJECT_DIR}") {
                        // We build the docker container image
                        bat 'docker build -t %DOCKER_IMAGE_NAME%:%DOCKER_IMAGE_TAG% .'
                        // And tag the image with the "latest" image
                        bat 'docker tag %DOCKER_IMAGE_NAME%:%DOCKER_IMAGE_TAG% %DOCKER_IMAGE_NAME%:latest'
                    }
                }
            }
        }

        stage('Test Docker Image Locally') {
            // Spining up a test Docker image and then testing it
            steps {
                echo "Testing the Docker Image Locally"
                script {
                    dir("${PROJECT_DIR}") {
                        bat '''
                        docker run -d -p 5001:5000 --name test-flask %DOCKER_IMAGE_NAME%:%DOCKER_IMAGE_TAG%
                        ping -n 31 127.0.0.1 > nul
                        curl http://localhost:5001 || echo "Warning: Could not reach app"
                        docker stop test-flask
                        docker rm test-flask
                        '''
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                echo "Pushing Image to Docker Hub"
                script {
                    // Here we bind credentials. To simply explain, it means using the "Credentials Binding plugin"
                    // [via the "withCredentials" step] to securely inject secrets (passwords, keys, tokens)
                    // from Jenkins' credential store into ***temporary*** environment variables, making them available
                    // ***ONLY*** within the specific block of the pipeline script, instead of hard-coding them directly
                    //
                    // Such credential binding helps prevent the need for hard-coding them directly 
                    // and prevents exposure in logs or source code
                    // See https://www.jenkins.io/doc/pipeline/steps/credentials-binding/ for more information
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable : 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        bat 'docker login -u %DOCKER_USER% -p %DOCKER_PASS%'

                        bat 'docker push %DOCKER_IMAGE_NAME%:%DOCKER_IMAGE_TAG%'
                        bat 'docker push %DOCKER_IMAGE_NAME%:latest'
                    }
                }
            }
        }

        stage('Infracost Estimate') {
            // Here we estimate the cost of such infrastructure being done
            steps {
                echo "Estimating Infrastructure Costs"
                script {
                    withCredentials([string(credentialsId: 'Infracost-API-Key', variable: 'INFRACOST_API_KEY')]) {
                        // The 'INFRACOST_API_KEY' environment variable is available ONLY inside this block
                        dir("${PROJECT_DIR}/terraform/azure") {
                            bat '''
                            infracost breakdown --path . --format table || echo "Infracost not available, skipping..."
                            '''
                        }
                    }
                }
            }
        }

        stage("Terraform Init & Plan") {
            steps {
                echo "Initializing and planning Terraform"
                script {
                    // Here we bind credentials. To simply explain, it means using the "Credentials Binding plugin"
                    // [via the "withCredentials" step] to securely inject secrets (passwords, keys, tokens)
                    // from Jenkins' credential store into ***temporary*** environment variables, making them available
                    // ***ONLY*** within the specific block of the pipeline script, instead of hard-coding them directly
                    //
                    // Such credential binding helps prevent the need for hard-coding them directly 
                    // and prevents exposure in logs or source code
                    // See https://www.jenkins.io/doc/pipeline/steps/credentials-binding/ for more information
                    dir("${PROJECT_DIR}/terraform/azure") {
                        withCredentials([
                            usernamePassword(credentialsId: 'azure-sp', usernameVariable: "ARM_CLIENT_ID",passwordVariable: 'ARM_CLIENT_SECRET'),
                            string(credentialsId: 'azure-tenant-id', variable: "ARM_TENANT_ID"),
                            string(credentialsId: 'azure-subscription-id', variable: 'ARM_SUBSCRIPTION_ID')
                        ]) {
                            bat 'set ARM_CLIENT_ID=${ARM_CLIENT_ID}'
                            bat 'set ARM_CLIENT_SECRET=${ARM_CLIENT_SECRET}'
                            bat 'set ARM_TENANT_ID=${ARM_TENANT_ID}'
                            bat 'set ARM_SUBSCRIPTION_ID=${ARM_SUBSCRIPTION_ID}'

                            bat 'terraform init -reconfigure'
                            bat 'terraform plan -out=tfplan'
                        }
                    }
                }
            }
        }

        stage('Deploy Terraform Infrastructure') { 
            steps {
                echo "Deploying the infrastructure to Azure!"
                script {
                    dir("${PROJECT_DIR}/terraform/azure") {
                        withCredentials([
                                usernamePassword(credentialsId: 'azure-sp', usernameVariable: "ARM_CLIENT_ID",passwordVariable: 'ARM_CLIENT_SECRET'),
                                string(credentialsId: 'azure-tenant-id', variable: "ARM_TENANT_ID"),
                                string(credentialsId: 'azure-subscription-id', variable: 'ARM_SUBSCRIPTION_ID')
                            ]) {
                                bat 'set ARM_CLIENT_ID=${ARM_CLIENT_ID}'
                                bat 'set ARM_CLIENT_SECRET=${ARM_CLIENT_SECRET}'
                                bat 'set ARM_TENANT_ID=${ARM_TENANT_ID}'
                                bat 'set ARM_SUBSCRIPTION_ID=${ARM_SUBSCRIPTION_ID}'

                                bat 'terraform apply -auto-approve tfplan'
                        }
                    }
                }
            }
        }

        stage('Deploy Application to Azure VM') { 
            steps {
                echo "Deploying the infrastructure to Azure VM!"
                script {
                    dir("${PROJECT_DIR}/terraform/azure") {
                        withCredentials([
                            usernamePassword(credentialsId: 'azure-sp', usernameVariable: "ARM_CLIENT_ID",passwordVariable: 'ARM_CLIENT_SECRET'),
                            string(credentialsId: 'azure-tenant-id', variable: "ARM_TENANT_ID"),
                            string(credentialsId: 'azure-subscription-id', variable: 'ARM_SUBSCRIPTION_ID'),
                            sshUserPrivateKey(credentialsId: 'azure-ssh-key', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USERNAME')
                        ]) {

                            // Set the appropriate environmental variables
                            bat 'set ARM_CLIENT_ID=${ARM_CLIENT_ID}'
                            bat 'set ARM_CLIENT_SECRET=${ARM_CLIENT_SECRET}'
                            bat 'set ARM_TENANT_ID=${ARM_TENANT_ID}'
                            bat 'set ARM_SUBSCRIPTION_ID=${ARM_SUBSCRIPTION_ID}'

                            // Restrict access to the SSH KEY FILE to only the user running the Jenkins agent
                            // This is intended to allow the SSH operation to go through
                            // 
                            // This is because Jenkins is running on my Windows computer under the SYSTEM account, 
                            // so we needed to ensure that only the SYSTEM account can get access to it
                            //
                            // This is because the Jenkins deployment on Windows is EXCEPTIONALLY finnicky
                            //
                            // That way, the SSH operation can work
                            bat """
                                icacls "%SSH_KEY_FILE%" /reset
                                icacls "%SSH_KEY_FILE%" /grant:r "NT AUTHORITY\\SYSTEM:(F)"
                                icacls "%SSH_KEY_FILE%" /inheritance:r
                            """

                            def instanceIP = bat(script: "@terraform output -raw instance_public_ip", returnStdout: true).trim()
                            echo "Deploying to ${$vmIP}"

                            // Need to wait for instance to be ready
                            bat "ping -n 31 127.0.0.1 > nul"

                            // We now try to get connected to SSH on the VM
                            withEnv(["INSTANCE_IP=${instanceIP}"]) {
                                bat """
                                    ssh -o StrictHostKeyChecking=no -i "%SSH_KEY_FILE%" %SSH_USERNAME%@%INSTANCE_IP% "echo Waiting for Docker... && until systemctl is-active --quiet docker; do sleep 5; done && sudo docker pull ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} && sudo docker stop ${APP_NAME} || true && sudo docker rm ${APP_NAME} || true && sudo docker run -d -p 5000:5000 -e CLOUD_PROVIDER=${CLOUD_PROVIDER} --name ${APP_NAME} ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                                """
                                echo "SSH is now ready!"

                                echo "Application deployed successfully!"
                                echo "Access at: http://${instanceIP}:5000"
                            }
                        }
                    }
                }
            }
        }
    }

    // Actions to be performed after the main stages of the pipeline are finished
    post {
        success {
            echo "The pipeline for deploying ${APP_NAME} into ${CLOUD_PROVIDER} infrastructure has succesfully completed!"
        }
        failure {
            echo  "The pipeline for deploying ${APP_NAME} into ${CLOUD_PROVIDER} infrastructure has failed!"
        }
        always {
            // This will always happen, no matter what the case
            //
            // We force Docker to remove all unused containers, networks, images (both dangling and unused), and optionally, volumes
            // See the following documentation page for further details: https://docs.docker.com/reference/cli/docker/system/prune/
            bat 'docker system prune -f'
        }
    }
}